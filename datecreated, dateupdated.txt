ALTER TABLE GameRecords
ADD COLUMN DateCreated DATETIME(3) DEFAULT CURRENT_TIMESTAMP(3),
ADD COLUMN DateLastUpdated DATETIME(3) DEFAULT CURRENT_TIMESTAMP(3) ON UPDATE CURRENT_TIMESTAMP(3);

New rows:
‚úÖ DateCreated will default to the current UTC timestamp when inserted.
‚úÖ DateLastUpdated will default to the current UTC timestamp and auto-update on future changes.

Existing rows:
‚ùå Will not get automatically populated.
Both DateCreated and DateLastUpdated will be NULL for existing records.

To backfill existing rows:
UPDATE GameRecords
SET
  DateCreated = UTC_TIMESTAMP(),
  DateLastUpdated = UTC_TIMESTAMP()
WHERE DateCreated IS NULL OR DateLastUpdated IS NULL;

Yes, you will need to modify your stored procedures if you want to properly manage the new DateCreated and DateLastUpdated columns during upserts.

Here's how to handle both:

‚úÖ Best Practice for DateCreated
Set only on insert

Leave it alone on update (so you preserve the original creation time)

‚úÖ Best Practice for DateLastUpdated
Let MySQL auto-update it using the ON UPDATE CURRENT_TIMESTAMP(3) clause (you don't need to manually touch it in your procedure unless you want full control)

üëá Example adjustment for your upsert procedure:
Suppose your existing procedure has an UPDATE ... WHERE ...; followed by an INSERT ... ON DUPLICATE KEY UPDATE ...; or similar logic. Here's what you should consider:

If you're doing INSERTs:
INSERT INTO GameRecords (
    ID, Name, Description, GameID, ..., DateCreated
)
VALUES (
    inputID, inputName, inputDescription, inputGameID, ..., UTC_TIMESTAMP()
)
DateLastUpdated will be automatically set by MySQL.

If you're doing UPDATEs:
You do not need to manually set DateLastUpdated if your column is defined with ON UPDATE CURRENT_TIMESTAMP(3).

But do not include DateCreated in the UPDATE clause, or it will overwrite the original timestamp.